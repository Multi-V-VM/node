// Host stub for genccode when cross-compiling for WASI
// This runs on the host system to generate assembly or C files from ICU data
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <string>

int main(int argc, char* argv[]) {
  // Parse command line arguments
  const char* output_file = nullptr;
  const char* input_file = nullptr;
  const char* entry_point = nullptr;
  std::string destdir;
  
  for (int i = 1; i < argc; i++) {
    if (strcmp(argv[i], "-d") == 0 || strcmp(argv[i], "--destdir") == 0) {
      if (i + 1 < argc) {
        destdir = argv[++i];
        if (!destdir.empty() && destdir.back() != '/') {
          destdir += '/';
        }
      }
    } else if (strcmp(argv[i], "-n") == 0 || strcmp(argv[i], "--name") == 0) {
      if (i + 1 < argc) {
        entry_point = argv[++i];
      }
    } else if (strcmp(argv[i], "-e") == 0 || strcmp(argv[i], "--entrypoint") == 0) {
      if (i + 1 < argc) {
        entry_point = argv[++i];
      }
    } else if (strcmp(argv[i], "-o") == 0) {
      if (i + 1 < argc) {
        output_file = argv[++i];
      }
    } else if (argv[i][0] != '-') {
      // Non-option argument is input file
      if (!input_file) {
        input_file = argv[i];
      }
    }
  }
  
  if (!input_file) {
    fprintf(stderr, "Error: No input file specified\n");
    return 1;
  }
  
  // Use default entry point if not specified
  if (!entry_point) {
    entry_point = "icudt77_dat";
  }
  
  // Determine output file name
  std::string outfile;
  if (output_file) {
    outfile = destdir + output_file;
  } else {
    // Extract filename from input path
    std::string infile(input_file);
    size_t pos = infile.find_last_of("/\\");
    std::string basename = (pos != std::string::npos) ? infile.substr(pos + 1) : infile;
    
    // Replace extension with .S
    pos = basename.find_last_of(".");
    if (pos != std::string::npos) {
      basename = basename.substr(0, pos);
    }
    outfile = destdir + basename + "_dat.S";
  }
  
  // Check if input file exists and get its size
  FILE* inf = fopen(input_file, "rb");
  if (!inf) {
    fprintf(stderr, "Error: Could not open input file: %s\n", input_file);
    return 1;
  }
  
  // Get file size
  fseek(inf, 0, SEEK_END);
  long filesize = ftell(inf);
  fclose(inf);
  
  // Generate assembly file
  FILE* out = fopen(outfile.c_str(), "w");
  if (!out) {
    fprintf(stderr, "Error: Could not create output file: %s\n", outfile.c_str());
    return 1;
  }
  
  // Write assembly for including binary data
  // Check if we're generating for macOS (gcc-darwin)
  bool is_macos = false;
  for (int i = 1; i < argc; i++) {
    if (strcmp(argv[i], "-a") == 0 && i + 1 < argc) {
      if (strstr(argv[i+1], "darwin") != nullptr) {
        is_macos = true;
      }
      break;
    }
  }
  
  fprintf(out, "# Generated by genccode stub for WASI cross-compilation\n");
  
  if (is_macos) {
    // macOS-specific assembly
    fprintf(out, ".globl _%s\n", entry_point);
    fprintf(out, "#ifdef U_HIDE_DATA_SYMBOL\n");
    fprintf(out, "\t.private_extern _%s\n", entry_point);
    fprintf(out, "#endif\n");
    fprintf(out, "\t.data\n");
    fprintf(out, "\t.const\n");
    fprintf(out, "\t.balign 16\n");
    fprintf(out, "_%s:\n", entry_point);
  } else {
    // Generic assembly for WASI and other platforms
    fprintf(out, ".globl %s\n", entry_point);
    fprintf(out, ".section .rodata\n");
    fprintf(out, ".align 8\n");
    fprintf(out, "%s:\n", entry_point);
  }
  
  fprintf(out, ".incbin \"%s\"\n", input_file);
  
  if (is_macos) {
    fprintf(out, "\n");
  } else {
    fprintf(out, "%s_size:\n", entry_point);
    fprintf(out, ".long %ld\n", filesize);
  }
  
  fclose(out);
  
  return 0;
}